using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Telegram.Bot.Generators;

[Generator]
public sealed class JsonAttributesGenerator : ISourceGenerator
{
    // ==============================

    private const string Placeholder = @"// <auto-generated />
using System.Text.Json.Serialization;

namespace {0};

public interface IAutoGenerated{1}
{{
{2}
}}
";

    // ==============================

    private const string PropertyPlaceholder = @"    [JsonPropertyName(""{0}"")]
    {1} {2} {{ get; set; }}";

    // ==============================

    private const string IgnorePlaceholder = "    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]";

    // ==============================

    private const string NewLinePlaceholder = @"
";

    // ==============================

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new JsonAttributesSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not JsonAttributesSyntaxReceiver receiver)
            return;

        //SpinWait.SpinUntil(() => Debugger.IsAttached);

        Compilation compilation = context.Compilation;

        INamedTypeSymbol? jsonPropertyNameAttr =
            compilation.GetTypeByMetadataName("System.Text.Json.Serialization.JsonPropertyNameAttribute");
        INamedTypeSymbol? jsonIgnoreAttribute =
            compilation.GetTypeByMetadataName("System.Text.Json.Serialization.JsonIgnoreAttribute");
        INamedTypeSymbol? newtonsoftPropertyAttr =
            compilation.GetTypeByMetadataName("Newtonsoft.Json.JsonPropertyAttribute");

        foreach (TypeDeclarationSyntax typeSyntax in receiver.Candidates)
        {
            SemanticModel model = compilation.GetSemanticModel(typeSyntax.SyntaxTree);
            var type = (ITypeSymbol) model.GetDeclaredSymbol(typeSyntax)!;

            var properties = new List<string>();

            foreach (IPropertySymbol prop in type.GetMembers().OfType<IPropertySymbol>().Where(p =>
                         p.DeclaredAccessibility == Accessibility.Public && p.GetMethod != null && p.SetMethod != null))
            {
                // skip this property if it already has the JsonIgnoreAttribute or the JsonPropertyNameAttribute
                ImmutableArray<AttributeData> attributes = prop.GetAttributes();

                AttributeData? newtonsoftAttr = null;
                var skip = false;
                foreach (AttributeData attribute in attributes)
                {
                    if (SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, jsonPropertyNameAttr) ||
                        SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, jsonIgnoreAttribute))
                    {
                        skip = true;
                        break;
                    }

                    if (SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, newtonsoftPropertyAttr))
                        newtonsoftAttr = attribute;
                }

                if (skip || newtonsoftAttr == null)
                    continue;

                // Check if Newtonsoft's JsonProperty attribute has the declared DefaultValueHandling argument
                var newtonsoftIgnoreAttr =
                    newtonsoftAttr.NamedArguments.FirstOrDefault(na => na.Key == "DefaultValueHandling");
                // In case it has - we add the corresponding ignore option for System.Text.Json
                bool addIgnoreAttr = newtonsoftIgnoreAttr.Key == "DefaultValueHandling" &&
                                     (int)newtonsoftIgnoreAttr.Value.Value! == 1; // 1 stands for DefaultValueHandling.Ignore

                // declare the variables for GetPropertyPlaceholder method
                string propertyName = prop.Name;
                string propertyFullTypeName = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                // get the property placeholder text and append it to the list
                string propertyPlaceholder = GetPropertyPlaceholder(propertyName, propertyFullTypeName, addIgnoreAttr);
                properties.Add(propertyPlaceholder);
            }

            // declare the variables for GetPlaceholder method
            var namespaceName = type.ContainingNamespace.ToString();
            string classNameWithTypeParameters = type.ToString().Split('.').Last();
            string content = string.Join(NewLinePlaceholder, properties);

            // get the auto-generated source code for this record/class type and apply it to the compilation context
            string classPlaceholder = GetPlaceholder(namespaceName, classNameWithTypeParameters, content);

            context.AddSource($"I{type.Name}.generated.cs", classPlaceholder);
        }
    }

    private static string GetPlaceholder(string namespaceName, string classNameWithTypeParameters, string content)
    {
        return string.Format(Placeholder, namespaceName, classNameWithTypeParameters, content);
    }

    private static string GetPropertyPlaceholder(string propertyName, string propertyFullTypeName, bool addIgnoreAttr)
    {
        string snakeCasePropertyName = propertyName.ToSnakeCase();
        var sb = new StringBuilder();
        if (addIgnoreAttr)
            sb.Append(IgnorePlaceholder).Append(NewLinePlaceholder);
        sb.AppendFormat(PropertyPlaceholder, snakeCasePropertyName, propertyFullTypeName, propertyName);
        return sb.ToString();
    }
}
