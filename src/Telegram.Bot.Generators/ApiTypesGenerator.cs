using System.Diagnostics;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Telegram.Bot.Generators.Extensions;

namespace Telegram.Bot.Generators;

[Generator]
public sealed class ApiTypesGenerator : ISourceGenerator
{
    // ==============================

    private const string Placeholder = @"// <auto-generated />
namespace {0};

/// <summary>
{3}
/// </summary>
public partial class {1}
{{
{2}
}}
";

    // ==============================

    private const string PropertyPlaceholder = @"
    /// <summary>
{3}
    /// </summary>
    [System.Text.Json.Serialization.JsonPropertyName(""{0}"")]
    [Newtonsoft.Json.JsonProperty(""{0}"")]
    public {1} {2} {{ get; set; }}";

    // ==============================

    private const string SummaryLinePlaceholder = "/// {0}";

    // ==============================

    private const string NewLine = "\n";

    // ==============================

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ExistingApiTypesSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not ExistingApiTypesSyntaxReceiver existingApiTypesSyntaxReceiver)
            return;

        var existingApiTypes = existingApiTypesSyntaxReceiver.ExistingApiTypes;

        // For debugging in Visual Studio
        //Debugger.Launch();

        // For debugging in Rider (after build is started, go Run -> Attach to Process... from toolbar)
        //SpinWait.SpinUntil(() => Debugger.IsAttached);

        AdditionalText? apiTypesFileData = context.AdditionalFiles.FirstOrDefault(f => f.Path.EndsWith("types.json"));
        if (apiTypesFileData == null)
        {
            throw new FileNotFoundException(
                "File containing the API types data was not found in the Telegram.Bot project.",
                "types.json");
        }

        using FileStream apiTypesFile = File.OpenRead(apiTypesFileData.Path);
        var types = JsonSerializer.Deserialize<List<BotApiType>>(apiTypesFile)!;

        foreach (BotApiType botApiType in types)
        {
            if (existingApiTypes.FirstOrDefault(t =>
                {
                    SemanticModel model = context.Compilation.GetSemanticModel(t.SyntaxTree);
                    var type = (ITypeSymbol)model.GetDeclaredSymbol(t)!;
                    return type.Name == botApiType.TypeName;
                }) is { } existingApiType
                && existingApiType.Modifiers.All(m => m.Text != "partial"))
            {
                // Skip this botApiType if non-partial class with corresponding name already exists
                // We want to declare some types manually without generating them
                continue;
            }

            // TODO add support for Required and Ignore attributes
            // TODO allow sub-namespaces for some types

            var namespaceName = "Telegram.Bot.Types";
            string data = GetPlaceholder(botApiType, namespaceName);

            context.AddSource($"{botApiType.TypeName}.generated.cs", data);
        }
    }

    private static string GetPlaceholder(BotApiType type, string namespaceName)
    {
        string content = string.Join(NewLine, type.Parameters.Select(param =>
            GetPropertyPlaceholder(param, type.TypeName)));
        return string.Format(Placeholder,
            namespaceName,
            type.TypeName,
            content,
            GetSummary(type.TypeDescription, padLeftWidth: 0));
    }

    private static string GetPropertyPlaceholder(BotApiTypeParameter parameter, string typeName)
    {
        string pascalName = parameter.ParameterName.ToPascalCase();
        return string.Format(PropertyPlaceholder,
            parameter.ParameterName,
            !parameter.IsEnum ? parameter.ParameterTypeName : $"Telegram.Bot.Types.Enums.{parameter.ParameterTypeName}",
            // TODO temporary solution
            pascalName != typeName ? pascalName : $"{pascalName}1",
            GetSummary(parameter.ParameterDescription));
    }

    private static string GetSummary(string description, int padLeftWidth = 4)
    {
        string[] descriptionParts = description.Split('\n');
        return string.Join("\n", descriptionParts.Select(part =>
            string.Format(SummaryLinePlaceholder, part).PadLeft(padLeftWidth)));
    }
}
